import axios from 'axios'
import dompurify from 'dompurify'

export default class Search {

  // 1. create properties that select DOM elements and keep track of useful data
  constructor() {
    // cross site data to allow this to work
    this._csrf = document.querySelector('[name="_csrf"]').value
    // lookup the html class of the search icon in the header.
    this.headerSearchIcon = document.querySelector(".header-search-icon")
    this.injectHTML()  // brad put this at the top...
    this.overlay = document.querySelector('.search-overlay')
    // class names are prefaced with a .
    // id's are prefaced with a #
    this.closeIcon = document.querySelector('.close-live-search')
    this.inputField = document.querySelector('#live-search-field')
    this.resultsArea = document.querySelector('.live-search-results')
    this.loaderIcon = document.querySelector('.circle-loader')  // spinning wait thing thing
    this.typingWaitTimer
    // for the search text
    this.previousValue = ""
    this.events()
  }

  // 2. Events - clicks, scrolls, etc
  events() {
    // use an arrow function so that the 'this' keyword does not change
    this.headerSearchIcon.addEventListener("click", (e) => {
      e.preventDefault()
      this.openOverlay()
    })

    this.closeIcon.addEventListener("click", (e) => {
      // e.preventDefault()
      this.closeOverlay()
    })

    // watch for input in the search field
    this.inputField.addEventListener("keyup", ()=> this.keyPressHandler())
  }

  // 3. Methods area
  openOverlay() {
    this.overlay.classList.add("search-overlay--visible")
    // need to wait a moment before setting focus on the input field. Some browsers not work on focus right away.
    // setTimeout runs a function after a specified wait.
    setTimeout(() => this.inputField.focus(), 50 )
  }
  closeOverlay() { this.overlay.classList.remove("search-overlay--visible")}

  keyPressHandler() {
    let value = this.inputField.value
    // if the user clears the search input field, don't try to find nothing. hur hur.
    if (value == "") {
      clearTimeout(this.typingWaitTimer)
      this.hideLoaderIcon()
      this.hideResultsArea()
    }

    if(value != "" && value != this.previousValue) {
      // clear any previous timers so we don't stack them. tard.
      clearTimeout(this.typingWaitTimer)
      this.showLoaderIcon()
      this.hideResultsArea()
      this.typingWaitTimer = setTimeout(() => this.sendRequest(), 700)  // milliseconds to wait
      console.log('typeing wait Timer started and shit')
    }
    this.previousValue = value
  }

  sendRequest() {
    // axios call returns a Promise. 
    //console.log('sendRequest before axios call ' + this.inputField.value)
    axios.post('/search', {_csrf: this._csrf, searchTerm: this.inputField.value})
      .then((response)=>{
        console.log(response.data)
        this.renderResultsHTML(response.data)
      })
      .catch(()=>{
        alert("the request fail. #fail, #loser.")
      })
  }

  // create/render some HTML with SEARCH results for the luser. 
  renderResultsHTML(posts) {
    if (posts.length) {
      // Lesson 91 - sanitize the HTML headed to the browser, er, generated by the front end from data it got from the backend which
      // could be tainted with badness.
      this.resultsArea.innerHTML = dompurify.sanitize(
          `<div class="list-group shadow-sm">
          <div class="list-group-item active"><strong>Search Results</strong> (${posts.length} ${posts.length > 1 ? ` items found` : ` item found`})</div>

          ${posts.map((post) => {
            let pD = new Date(post.createdDate)
            return `<a href="/post/${post._id}" class="list-group-item list-group-item-action">
                <img class="avatar-tiny" src="${post.author.avatar}"> <strong>${post.title}</strong>
                <span class="text-muted small">by ${post.author.username} on ${pD.getMonth()+1}/${pD.getDate()}/${pD.getFullYear()}</span>
              </a>`
          }).join('')}
        </div>`)
    } else {
      this.resultsArea.innerHTML = `<p class="alert alert-danger text-center shadow-sm">No results for that search</p>`
    }
    this.hideLoaderIcon()
    this.showResultsArea()
  }

  showLoaderIcon() {
    this.loaderIcon.classList.add("circle-loader--visible")
  }
  hideLoaderIcon() {
    this.loaderIcon.classList.remove("circle-loader--visible")
  }

  showResultsArea() { this.resultsArea.classList.add("live-search-results--visible")}
  hideResultsArea() { this.resultsArea.classList.remove("live-search-results--visible")}


  // going to push some HTML into the page to create client side search
  injectHTML() {
    document.body.insertAdjacentHTML('beforeend', `<div class="search-overlay">
    <div class="search-overlay-top shadow-sm">
      <div class="container container--narrow">
        <label for="live-search-field" class="search-overlay-icon"><i class="fas fa-search"></i></label>
        <input type="text" id="live-search-field" class="live-search-field" placeholder="What are you interested in?">
        <span class="close-live-search"><i class="fas fa-times-circle"></i></span>
      </div>
    </div>

    <div class="search-overlay-bottom">
      <div class="container container--narrow py-3">
        <div class="circle-loader"></div>
        <div class="live-search-results">

        </div>
      </div>
    </div>
  </div>`)
  }
}